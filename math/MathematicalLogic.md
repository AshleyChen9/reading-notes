![cover](https://img3.doubanio.com/view/subject/l/public/s5939210.jpg)

    作者: 邢滔滔 
    出版社: 北京大学出版社
    出版年: 2008-8
    页数: 274
    定价: 28.00元
    装帧: 简
    ISBN: 9787301112557

[豆瓣链接](https://book.douban.com/subject/3175037/)

- [第1章 绪论：从直观到形式](#%e7%ac%ac1%e7%ab%a0-%e7%bb%aa%e8%ae%ba%e4%bb%8e%e7%9b%b4%e8%a7%82%e5%88%b0%e5%bd%a2%e5%bc%8f)
  - [1.从“矛盾”说起](#1%e4%bb%8e%e7%9f%9b%e7%9b%be%e8%af%b4%e8%b5%b7)
  - [2.直观上地推理](#2%e7%9b%b4%e8%a7%82%e4%b8%8a%e5%9c%b0%e6%8e%a8%e7%90%86)
  - [3.正确推理](#3%e6%ad%a3%e7%a1%ae%e6%8e%a8%e7%90%86)
    - [3.1 合规则性](#31-%e5%90%88%e8%a7%84%e5%88%99%e6%80%a7)
    - [3.2 有效性](#32-%e6%9c%89%e6%95%88%e6%80%a7)
  - [4.一阶语言](#4%e4%b8%80%e9%98%b6%e8%af%ad%e8%a8%80)
    - [4.1 命题成分](#41-%e5%91%bd%e9%a2%98%e6%88%90%e5%88%86)
    - [4.2 外延性与真](#42-%e5%a4%96%e5%bb%b6%e6%80%a7%e4%b8%8e%e7%9c%9f)
    - [4.3 一阶符号语言](#43-%e4%b8%80%e9%98%b6%e7%ac%a6%e5%8f%b7%e8%af%ad%e8%a8%80)
  - [5.推演系统](#5%e6%8e%a8%e6%bc%94%e7%b3%bb%e7%bb%9f)
    - [5.1 公式模式与推理规则](#51-%e5%85%ac%e5%bc%8f%e6%a8%a1%e5%bc%8f%e4%b8%8e%e6%8e%a8%e7%90%86%e8%a7%84%e5%88%99)
    - [5.2 形式推演系统](#52-%e5%bd%a2%e5%bc%8f%e6%8e%a8%e6%bc%94%e7%b3%bb%e7%bb%9f)
- [第2章 集合](#%e7%ac%ac2%e7%ab%a0-%e9%9b%86%e5%90%88)
  - [1.集合（不）是什么？](#1%e9%9b%86%e5%90%88%e4%b8%8d%e6%98%af%e4%bb%80%e4%b9%88)
  - [2.关系](#2%e5%85%b3%e7%b3%bb)
    - [2.1 等价关系](#21-%e7%ad%89%e4%bb%b7%e5%85%b3%e7%b3%bb)
    - [2.2 序关系](#22-%e5%ba%8f%e5%85%b3%e7%b3%bb)
  - [3.函数](#3%e5%87%bd%e6%95%b0)
  - [4.可数集与不可数集](#4%e5%8f%af%e6%95%b0%e9%9b%86%e4%b8%8e%e4%b8%8d%e5%8f%af%e6%95%b0%e9%9b%86)
- [第3章 一阶语言的语形](#%e7%ac%ac3%e7%ab%a0-%e4%b8%80%e9%98%b6%e8%af%ad%e8%a8%80%e7%9a%84%e8%af%ad%e5%bd%a2)
  - [1.字母表](#1%e5%ad%97%e6%af%8d%e8%a1%a8)
  - [2.归纳定义](#2%e5%bd%92%e7%ba%b3%e5%ae%9a%e4%b9%89)
  - [3.项](#3%e9%a1%b9)
  - [4.公式](#4%e5%85%ac%e5%bc%8f)
  - [5.递归定义](#5%e9%80%92%e5%bd%92%e5%ae%9a%e4%b9%89)
  - [6.自由和约束 代入](#6%e8%87%aa%e7%94%b1%e5%92%8c%e7%ba%a6%e6%9d%9f-%e4%bb%a3%e5%85%a5)

# 第1章 绪论：从直观到形式
## 1.从“矛盾”说起
1. 同时肯定和否定同一个主张就是矛盾，而不管这个主张是什么。
2. 我们有一条普遍的形而上学原则，即所有的矛盾都不可能为真。
3. 这条“（不）矛盾律”同时是我们思想的“最确定的推理原则”或规则，这条规则说：如果你从一个主张推出了矛盾，你就要否定这个主张。后来的西方人把这条思想规则称为`“reductio ad absurdum”（RAA）`。

## 2.直观上地推理
把句子的意义，或表达在句子之中地思想称为`命题`。命题有`真假`。

推理是一组命题，其中之一（称为`结论`）是从其他的（全部或部分）命题（称为`前提`）推出的，而这个“推出”关系，表现为某种结构。

## 3.正确推理
一个正确的推理，说的是它的前提和结论之间有某种确定的关系。

### 3.1 合规则性
```
所有这样的都是那样的。某某是这样的。
------
某某是那样的。
```

这是一个`推理规则`。一般而言，一个推理规则首先明确一个基本推理地形式，然后规定：具有这种形式的推理都是合乎此规则地。

若干推理规则组成一个`逻辑系统`。一个推理地每一步（其中的每个基本推理）如果都合乎这个系统中地某个规则，则称这个推理在这个系统中是`合规则的`，否则称它在其中不合规则。

对于一个推理系统而言，一个推理是正确的，当且仅当它在这个系统中是合规则的。

正如推理由命题组成，`推理形式`也是由`命题形式`组成的，而命题形式是由相应的命题表达式通过删除一些“有实义的”部分（即容许这些部分用其他的同类语言单位替换）构成的。

把命题形式中的代词换成一些`变项`符号，如把“某某”换成x，把“这样的”换成A，把“那样的”换成B等等。命题形式中未经变项替换的部分（如“所有的”），称为`逻辑常项`。

借助变项表示：

```
所有A都是B。x是A。
------
x是B。
```

因此，一个推理，如果把其中作前提和结论的命题分别代换成相应的命题形式，就得到这个推理地形式。

亚里士多德建立的三段论学说：

- 所有的S都是P。（全称肯定）
- 所有的S都不是P。（全称否定）
- 有些S是P。（特称肯定）
- 有些S不是P。（特称否定）

其中的逻辑常项是：“所有的”（全称量词）、“有些”（存在量词）、“是”和“不是”，而命题的主项和谓项是可以替换的。对于“韩非是人”、“这支矛不能刺破这张盾”这类的单称命题，传统逻辑把它们分别归到全称肯定和全称否定的形式里。这称为命题的`主谓形式分析`。

一般地，从每一个推理形式都能够类似地得到一些具体推理，而每一个这样得到的具体推理就叫做这个形式的一个`实例`，这个形式也称作它的诸实例的一个`模式`。

肯定前件式或分离规则：

```
如果p，则q；p
------
q
```

否定后件式：

```
如果p，则q；非q
------
非p
```

`排中律`：从任何前提都能推出形如“p或者非p”的结论。

### 3.2 有效性
从语义上判断一个推理是否正确，要看它的前提如何支持它的结论。前提100%支持结论地，我们称为`有效的`推理，否则称为非有效的。研究推理的有效性的称为`演绎推理`。与演绎推理相对的研究领域一般称为`归纳推理`，它关心前提对结论地不同支持程度。本书不讨论归纳逻辑，凡提到“逻辑”之处，皆指演绎逻辑。

我们把在任何可能得情形中都没有真实例的命题形式称为`矛盾式`，把矛盾式的实例称为`逻辑上假`的命题（或矛盾）。反之，在任何可能的情形中都只有真实例的命题形式是`有效式`，有效式的实例是`逻辑上真`的命题。

## 4.一阶语言
### 4.1 命题成分
命题中指称个体的成分为`个体项`，表达性质和关系的成分为`概念`。像“韩非”、“这支矛”等专名和确定指示词指称确定的个体，因此是个体项。概念的特点是，它们具有“空位”，当空位被确定的词项填充进去，我们就得到一个完整的命题。如概念“...是哲学家”有一个空位，用专名“亚里士多德”填充后，我们得到“亚里士多德是哲学家”这个命题，它表达一个确定的个体具有某个确定的性质；概念“...喜欢...”有前后两个空位，用名字“韩非”与“这支矛”分别填充后，我们得到“韩非喜欢这支矛”这个命题，它表达两个确定的个体具有某个确定的关系。关系可以是二元、三元...n元的（称为`n元概念`）。一个典型的二元概念是`等同`，就是“...等于...”，我们把一个个体的性质也称为`一元关系`。

对命题的这种`个体项——概念式分析`不同于传统逻辑的`主-谓式分析`，后者只讲性质。把“这支矛能刺破这张盾”这样的关系命题仅分析为“这支矛”具有“能刺破这张盾”这个性质。这种分析表达力较弱。

称“所有的”为`全称量词`，“有些”称为`存在量词`。变项x是`个体变项`。

我们一般用+和·分别表示加法和乘法，它们称为函数符号。这里的函数是某种运算，一元函数施于一个对象之上，n元函数施于n个对象之上，“变换”出一个对象（函数值）。

用`命题联结词`从已有命题构造出复合命题。

上述命题，总体上说，表达的是个体具有什么性质及个体间具有什么关系，我们称这类命题为`一阶命题`。一阶命题描述的世界，由个体、性质和关系（包括函数）组成，大部分的数学“世界”正是这样组成的，我们日常的世界，在某种哲学观点下也可以“看成”是这样组成的。

### 4.2 外延性与真
韩非、亚里士多德等个体分别`例示`了“...是人”这个性质；反过来，每个性质规定或“挑出”一些个体，就是那些例示了这个性质的个体，如“...是人”这个性质挑出了韩非、亚里士多德等个体。

性质“...是一只狗”和“...是你喜爱的动物”挑出了同一些个体，而这两个概念具有相同的外延，但这两个性质或概念显然是不同的。

在任何一阶命题里，都可以将具有相同外延的概念或具有共同指称的名字相互替换而不改变这个命题的真假。这是因为，一阶命题的真假只与个体是否例示关系有关，而与如何指称个体或如何表达关系无关。在这个意义上，只涉及一阶命题的语言是外延性的。

因此，对概念来说，我们可以忽略它的非外延方面的内容，而只考虑它所涉及的那些个体或个体序列。这种抽象的结果，逻辑学家称为`集合`。集合作为概念的外延，包含了性质或关系挑出的个体或个体序列。

一个集合所包含的东西，称为这个集合的`元素`。a是集合A的元素，记作$a \in A$。

`集合的外延性原则`：如果集合A与集合B包含相同的元素（就是说，对任意的x，$x \in A$当且仅当$x \in B$），则A与B就是同一个集合。

“...是一只狗”和“...是你喜爱的动物”，虽然是不同的概念，但作为集合，是同一个东西。

这样建立的集合概念恰好解释了命题的真假：命题“韩非是人”为真的充分必要条件，不需要再表述为韩非这个个体例示了性质“...是人”，而只要表述为这个个体属于这个性质决定的集合。

### 4.3 一阶符号语言
推理的有效性只与命题的真假有关，而命题的真假又只由个体的集合来决定，所以，探讨有效性问题就只需要关注集合和个体。这要求我们设计一种专供逻辑使用的语言，使其中的句子不再描述个体具有什么性质或关系，而描述个体或个体序列属于什么集合。就是说，这个语言中的“概念”不再表示个体的性质和关系，而表示个体或个体序列的集合，这个语言中的“名字”也不再有涵义，而只是指称。这个语言的句子，因此表达而且只表达一阶命题的真假。

语言首先需要以下这些词汇：

1. （对应于名字）`个体常项`：a,b,c等，它们指称论域里某些特定的个体；
2. （对应于概念）`谓词`：F,G,H等，表达论域中那些个体的集合和合体序列的集合；
3. `函数符号`：f,g,h等，表达论域上的函数；
4. 个体变项：x,y,z,u,v,...；
5. 全称量词$\forall$和存在量词$\exists$，它们使用在论域的个体之上；
6. 真值联结词：$\lnot,\land,\lor,\to$

表达一阶命题（的真假）的，称为`公式`。1-3称为`非逻辑符号`；4-6称为`逻辑符号`。所有这些符号组成一个语言的`字母表`。

当一个（一些）公式经解释后在一个结构中为真时，我们称这个结构为这个（这些）公式的`模型`。

任意一个一阶语言中，设$\Phi$为一组公式，$\varphi$为一个公式，我们用$\Phi \models \varphi$表达如下事实：$\Phi$的任何模型都是$\varphi$的模型。此时我们称$\varphi$是$\Phi$的`语义后承`。显然$\Phi \models \varphi$放在直观背景下来理解，它说的恰好是：从前提$\Phi$到结论$\varphi$的推理是有效的。

## 5.推演系统
### 5.1 公式模式与推理规则
自然语言中的推理：

```
7)所有跟亚里士多德同时代的人都是哲学家。 韩非是跟亚里士多德同时代的人。
------
韩非是哲学家。
```

在$L_1$中就“翻译”成如下推理：

7')

$$\forall x(G(x,b) \to F(x))\ G(a,b)$$

---

$$F(a)$$

我们用变项$\alpha,\beta$等代表$L_1$中的那些个体常项，用变项$\pi,\gamma$等代表其中的谓词，则7)中的三个命题的形式以及它们组成的推理形式就可以表达城：

7'')

$$\forall x(\pi(x,\beta) \to \gamma(x))\ \pi(\alpha,\beta)$$

---

$$\gamma(\alpha)$$

注意，$\alpha,\beta,\pi,\gamma$等不是一阶语言中的符号，而是我们为了讨论一阶语言的公式形式而使用的变项。因此，7'')中的那些符号序列不是一阶公式。这里出现了两个层次的语言，一是一阶语言（在这里具体是$L_1$），它是我们眼下讨论和研究的对象，称为`对象语言`；另一个是我们讨论对象语言时使用的语言，就目前情形而言，它是汉语加上一些特别的符号（包括$L_1$中的逻辑符号），这称为`元语言`。

7'')中的三个元语言公式，我们称为7')中相应的$L_1-$公式的模式。这跟前面介绍的模式概念是统一的。一般而言，一个`公式模式`是用元语言变项替换一个公式中的非逻辑符号而得到的，这个公式是这个模式的一个实例。

### 5.2 形式推演系统
假定我们选定了一个推演系统$\Im$。在任意一个一阶语言中，从一组给定的前提$\Phi$出发，经过一些列（有穷的）推理步骤，若每一步都合乎$\Im$的一个规则，而最后得到公式$\varphi$，我们就称这个过程是前提$\Phi$在$\Im$中对结论$\varphi$的一个`推演`。

如果在$\Im$中存在从$\Phi$到$\varphi$的一个推演，则称$\Phi$在$\Im$中`可推演`$\varphi$，记作$\Phi \vdash_\Im \varphi$。此时我们也称$\varphi$是$\Phi$的`语形后承`。

要求每一个推演都满足下面的条件：

1. 必须在有穷步内完成。
2. 我们可以能行地检验推演中每一个推理步骤是否合乎系统的某个规则。
3. 推演的前提与结论可以能行地找出来。

满足这些条件的证明系统称为`形式推演系统`。

如果在L中以下1~4都是能行可判定的，则称L是一个形式语言。

1. 任意一个符号是不是L的符号；
2. L中任意符号是一个逻辑符号还是非逻辑符号；
3. L中任意符号是哪一类逻辑符号或非逻辑符号；
4. 任意符号序列是不是一个L-公式或其组成部分。

我们要建立这样一个形式推演系统：对任意给定一个一阶形式语言L，

1. 它的规则在L中产生且仅产生有效推理地实例，这就是说，对任何L-公式集$\Phi$和公式$\varphi$，如果$\Phi \vdash \varphi$，则$\Phi \vDash \varphi$；
2. L中所有有效推理的实例，都可以用系统的规则产生，换言之，如果$\Phi \vDash \varphi$，则$\Phi \vdash \varphi$。

第一点称为系统的`可靠性`，第二点称为`完全性`。两者合起来就是这样一个要求：$\Phi \vDash \varphi$，当且仅当$\Phi \vdash \varphi$。这表明了语形后承和语义后承这两个概念（在外延上）的重合，精确解释了推理地合规性和有效性相互吻合的直观思想。一阶逻辑的这个结果，由哥德尔（Godel，1930）证明。

莱布尼茨将推理变成计算的思想，大概还蕴涵着这样一个要求：有一个机械过程，对任意的$\Phi$和$\varphi$，都可以能行地判定$\Phi \vdash \varphi$是否成立。这个要求称为系统的`可判定性`。但丘奇（A.Church,1936）证明，一般而言，形式推演系统不具有可判定性。与此相关的还有著名的哥德尔不完全性定理，它表明形式化的算术理论不能穷尽真算术命题。这些是形式化的代价，其中的哲学意义也许可以这样表述：当我们从直观一步步走向形式，确定性和清晰性都逐步加强，但直观方面的一些内容却不可避免地损失掉了。"

# 第2章 集合
## 1.集合（不）是什么？
只有一个元素的集合，称为`单元素`。

一般而言，如果$\varphi(x)$表示一个性质，则我们就用$\{x|\varphi(x)\}$表示所有具有此性质的元素的聚合，换言之：任给x,$x \in \{x|\varphi(x)\}$当且仅当x满足$\varphi$（即$\varphi(x)$成立）。

直观上看来，对任意一个集合，我们似乎可以设计一个概念来表述它；而任意一个概念，也似乎决定一个集合。这与弗雷格的观念（集合是概念的外延）吻合。

不含任何元素的集合称为`空集`。空集A因此是这样的集合：对任意的x，都有$x \in A$。

给定集合A与B，如果对任意x，$x \in A$当且仅当$x \in B$，则A=B。这即是`外延性原则`，它给出了集合的同一性条件。外延性原则保证了空集是唯一的。

**1.1 定义**：集合A是集合B的`子集`，记为$A \subseteq B$，当且仅当对任意的x，如果$x \in A$，则$x \in B$。

如果$A \subseteq B$且$A \ne B$，则称A是B的`真子集`，记为$A \subset B$。

集合的`确定性原则`：对任意的对象x和任意的集合A，$x \in A$或$x \notin A$。

在一个语言里，如果不仅允许量词使用在个体之上，而且允许它们使用在个体的性质和关系之上，则这个语言就不仅能谈论个体有什么性质（关系），而且能谈论个体的性质或关系有什么性质或关系。这称为`二阶语言`，研究其中推理的，称为`二阶逻辑`。二阶语言的论域里面不仅有个体，还有个体的集合。

**1.3 定义**：设A是集合，称集合$\{X|X \subseteq A\}$为A的`幂集`,记为$\mathcal P(A)$。直观上说，一个集合的幂集就是这个集合的所有子集的集合。

**1.5 定义**：给定集合A和B，
- 称集合$\{x|x \in A\ or\ x \in B\}$为A和B的并集，记为$A \cup B$
- 称集合$\{x|x \in A\ and\ x\in B\}$为A和B的交集，记为$A \cap B$
- 称集合$\{x|x \in A\ and\ x \notin B\}$为A和B的差集，记为A - B。

两个集合的并集和交集运算可以推广到任意多集合上。其元素都是集合的集合叫`集合族`。设A是一个集合族，我们
- A的并，记作$\cup A$，它是A中所有元素的并；
- A的交，记作$\cap A$，它是A中所有元素的交。

集合是某种统一体，是由“多”聚成的“一”。按照一种朴素的哲学观念，当我们用一个概念（谓词）“把握”了多个东西之后，这多就同时成了作为思想对象的一。

用上述观念解释康托尔，就似乎有以下结论：

1. 每个集合都有一个定义它的谓词；
2. 每个谓词都决定一个集合（其元素是所有满足这个谓词的对象）

现在人们意识到，这两点恐怕都错了，且都不是康托尔的原文。我们着重谈第二点，因为这是弗雷格关于每个性质决定一个集合的想法的另一种表述。文献上称这个想法为`一般概括原则`，它说的是：

对任意性质词$\varphi$，存在一个集合S，它的元素是所有满足这个性质的对象，即$S=\{x|\varphi(x)\}$。

1902年，罗素给弗雷格写了一封信，说明当$\varphi$表达某种集合的性质时，这个原则导致了矛盾。其推论如下：

**1.7 罗素悖论**：令$\varphi$为$X \notin X$。根据上述原则，存在集合$S=\{X|X \notin X\}$，即对任意X，$X \in S$当且仅当$X \notin X$。特别地，$S \in S$当且仅当$S \notin S$。矛盾。

直观上看，这里的$\varphi$表达性质“...不属于自身”，而S相当于所有不属于自身的集合的“集合”。如果$X \in S$，则根据S的定义，S有“...不属于自身”这个性质，即$S \notin S$；另一方面，如果$S \notin S$，则S具有“...不属于自身”这个性质，再根据S的定义，$S \in S$。所以，$S \in S$当且仅当$S \notin S$。矛盾。

不能简单地说集合是概念或谓词的外延，有的概念的外延不是集合，有的性质不对应任何集合，这是集合概念深藏不显的特性之一。

既然概念的外延不全是集合，一种处理方式是把概念的外延统称为`类`。有的类是集合，有的不是，不是集合的类（如罗素悖论里的S），叫做`真类`。

我们仍然无法解决关于性质的罗素悖论：有的性质能例示自身，如“...是抽象的”（“...是抽象的”这个性质是抽象的），有的不能，如“...是人”（“...是人”这个性质不是人）。"

## 2.关系
一般而言，给定任意n($\ge 1$)个对象$x_1,x_2,\cdots,x_n$，我们都可以构造一个`有序n元组`（或n元组）$x_1,x_2,\cdots,x_n$，其中的诸$x_i$不必不同，n称为这个有序组的`长度`。

规定：$<x_1,x_2,\cdots,x_m>=<y_1,y_2,\cdots,y_n>$当且仅当m=n且$x_1=y_1,x_2=y_2,\cdots,x_n=y_n$。

这就是说，有序组被其长度、构成对象及其顺序所决定。

如果R是一个n元关系，那么对任何的$<x_1,x_2,\cdots,x_n> \in R$，称$x_1,x_2,\cdots,x_n$具有关系R。特别对二元关系来说，如果存在集合A，B，使得对任何的$<x,y> \in R$，都有$x \in R,y \in R$，则称R为`从A到B的关系`。

- 集合{x|存在y，使得$<x,y> \in R$}叫做关系R的前域；
- 集合{x|存在y，使得$<y,x> \in R$}叫做关系R的后域。

集合$\{<x,y>|x \in A,y \in B\}$，称为集合A和B的`笛卡尔积`，记为$A \times B$。

直观上，$A \times B$就是把A中所有元素与B中所有元素一一配成有序对而组成的二元关系。显然，任何从A到B的关系，都是$A \times B$的子集。这使得我们可以把“R是从A到B的二元关系”简单地表示成：$R \subseteq A \times B$。

如果A=B，则称R是`A中的一个二元关系`。

设$n \ge 1,A_1,\cdots,A_n$是集合，则笛卡尔积$A_1 \times A_2 \times \cdots \times A_n=\{<x_1,x_2,\cdots,x_n>|x_1 \in A_1,x_2 \in A_2,\cdots,x_n \in A_n\}$。

若$A_1=A_2=\cdots=A_n=A$，则 $A_1 \times A_2 \times \cdots \times A_n$就简记为$A^n$。如果关系$R \subseteq A^n$，则称R为`A中的一个n元关系`。

### 2.1 等价关系
**2.1.1 定义**：设R是集合A中的二元关系。
- R是A中的`自反`关系，如果对于任意的$x \in A$，都有xRx。
- R是A中的`对称`关系，如果对任意的$x,y \in A$，若xRy则yRx。
- R是A中的`传递`关系，如果对任意的$x,y,z \in A$，若（xRy且yRz）则xRz。

**2.1.3 定义**：集合A中的二元关系R是A中的`等价关系`，如果R是A中的自反关系、对称关系和传递关系。

**2.1.4 定义**：令R是集合A中的一个等价关系，a是A的一个元素。称A的子集$\{x|x \in A\ and\ aRx\}$为a生成的`R-等价类`，记为$[a]_R$。

**2.1.5 引理**：令R是集合A中的一个等价关系。那么，对所有$x,y \in A$，如果$y \in [x]_R$，则$[x]_R = [y]_R$。

因此，一个等价类的所有元素都是“平等的”，它们都生成同一个等价类，其代表元可以在这个等价类中任意选取。

### 2.2 序关系
**2.2.1 定义**：集合A中的一个二元关系R是反对称的，如果对任意的$x,y \in A$，若(xRy 且 yRx)则x=y。

反对称关系的一个明显例子是自然数集N中的$\le$关系。

**2.2.2 定义**：集合A中的二元关系R称为A中的一个`偏序`，如果R是A中的自反、反对称和传递关系。

- 对于$x \in A$，如果不存在另一个$y \in A$，使得yRx，则称x为此偏序的一个`极小元`。
- 对于$x \in A$，如果不存在另一个$y \in A$，使得xRy，则称x为此偏序的一个`极大元`。

**2.2.4 定义**：集合A中的一个偏序R称为`全序`（或线性序），如果对任意$x,y \in A$，xRy和yRx必有一个成立。

- 自然数集N中的$\le$不仅是偏序，也是全序。
- 树是偏序。

**2.2.7 定义**：集合A中的一个偏序R称为一棵`树`，如果它有唯一的极小元a，而且对任意$x \in A$，{y|yRx}中的R是全序。

- A中元素称为此树的`结点`，极小元a称为此树的`根`。
- A的一个子集B是一条`枝`，如果
    1. $a \in B$；
    1. B中的R是全序；
    1. B是满足(1)和(2)的最大子集。
- 枝上的极大元素称为此树的`叶`。"

## 3.函数
**3.1 定义**：令A和B为非空集合。从A到B的二元关系R称为从A到B的`函数`，当且仅当

1. 对任意的$x \in A$，都有$y \in B$，使得xRy；
2. 如果存在$y,z \in B$，使得xRy并且xRz，则y=z。

A到B的函数f经常表示为:$f:A \to B$，a是A中的元素，f把a与B中的一个元素对应起来。

- B中的这个元素，称为f在a处的`函数值`，记为f(a)；
- A称为f的`定义域`；
- f在A上的函数值都在B中，称这些函数值的集合为f的`值域`。

如果f的定义域是笛卡尔集$A_1 \times A_2 \times \cdots \times A_n,n \ge 1$，则称f为一个`n元函数`（或A中的n元计算）。

设f是从A到B的函数，如果还有一个从B到C的函数g，则我们可以定义g和f的`复合函数`gf。

**3.2 定义**：设$f:A \to B$

1. 如果f的值域等于B，即任给$y \in B$，都有$x \in A$，使得f(x)=y，则称f为A到B的`满射`。
2. 如果对任意的$x,y \in A$，若f(x)=f(y)则x=y，即f的定义域中不同的元素对应于值域中不同的元素，则称f为A到B中的`单射`，会一一映射。
3. 如果f既是满射又是单射，则称f为A到B的`双射`，或一一对应。

一个A到B的双射f，建立了A和B的元素之间一对一的关系。这个关系，如果反过来考虑，则构成了B到A的双射。这就是说，有一个函数g，定义在B上，对任意的$y \in B,g(y)=A$中唯一的那个x，使得f(x)=y。这样的g，称为f的`反函数`，记为$f^{-1}$。"

## 4.可数集与不可数集
把一个集合的“大小”叫做A的`基数`，记为|A|。于是，集合A和集合B“一样大”就表为：|A|=|B|，这称为A和B`等势`，其定义就是：存在A到B的双射。

**4.1 引理**：集合间的等势是一种等价关系。

一个集合，若与自身的一个真子集等势，就称为`无穷集`，否则称为`有穷集`。

集合A是有穷的，当且仅当，或者A是空集，或者存在自然数n，使得{0,1,2,...,n}与A之间有双射。

A的大小有两种可能。一种是A与N本身等势，比如N与自身等势，偶数集与N等势等。这样的A称为`可数无穷`的，其元素可以列为：$a_0,a_1,a_3,\cdots$。另一种可能是，A与N之间没有一一对应，这样的A，其基数大于N的基数，不能用N来映满，称为`不可数`的。借用这些术语，可以把全部集合分为可数的与不可数的两个部分：`可数的`集合，包含全部可数无穷集合有穷集，其他是不可数集合。

**4.4 定义**：集合A是可数的，当且仅当，或者A是空集，或者存在从N到A上的满射f。

**4.6 引理**：设非空集合A是可数的，集合$B=\cup\{A^n | n \ge 1\}$，则B是可数无穷的。

**4.7 定理**：有些集合是不可数的。

证明：考虑由0、1两个数字组成的无穷序列，如01001110101...，令A为这样的序列的集合。我们用归谬法证明，A是不可数的。就是说，我们先假设A是可数的，然后从这个假设推出矛盾，由此得到这个假设的否定，即A不可数。

设A是可数的。根据可数集的定义，存在从N到A上的满射f。比如说，我们有以下的枚举：

```
f(0)=100011010100...
f(1)=011100000001...
f(2)=110011001111...
f(3)=100000111000...
```

注意等号右边的这个阵的对角线上的数字，即f(0)的第1个、f(1)的第2个...f(n)的n+1个...数字，它们组成一个无穷序列（在上面的例子里，这个序列是1100...）。把这个序列里的每个0换成1，每个1换成0，我们又得到一个新的无穷序列$\alpha$（在上面的例子里，这个$\alpha$序列是0011...）。显然$\alpha$属于A（它是由0、1两个数字组成的无穷序列）。因此f是满射，所以存在自然数m，使得$f(m)=\alpha$。但是，由$\alpha$的构造，我们知道，f(m)的m+1个数字与$\alpha$的第m+1个数字不同，即$f(m)\ne \alpha$。矛盾。因此，最初的假设为假，A是不可数的。

这是著名的`康托尔对角线定理`，由此得出以下推论：

1. 因为一个由0、1组成的无穷序列$a_0,a_1,a_3,\cdots$可以唯一对应于一个[0,1]区间里的实数a（用二进制表达），所以，对角线定理表明，[0,1]区间里的实数是不可数的（因此实数集也是不可数的）。
2. 一个由0、1组成的无穷序列$a_0,a_1,a_3,\cdots$也可以唯一对应于一个自然数集M，只要令$n \in M$当且仅当$a_n=0$即可。因此，对角线定理又表明，N的幂集$\mathcal{P}(N)$是不可数的。
3. 一个由0、1组成的无穷序列$a_0,a_1,a_3,\cdots$还可以看成对集合{0,1}的一个无穷长（有重复的）枚举，即从N到{0,1}上的一个满射f的值，使得$f(n)=a_n$。显然$a_0,a_1,a_3,\cdots$唯一对应于一个这样的f。因此，对角线定理还表明，从N到{0,1}上的函数的集合是不可数的。"

# 第3章 一阶语言的语形
## 1.字母表
**1.1 定义**：一个一阶语言$\mathcal L$的`字母表`由以下符号组成：
1. 一组非逻辑符号，其中包括：
   1. 一个（可能空的）个体常项集；
   2. 对每个$n \ge 1$，一个（可能空的）n元谓词集；
   3. 对每个$n \ge 1$，一个（可能空的）n元函数符号集。
2. 一组固定的逻辑符号，其中包含：
   1. 个体变项$x_0,x_1,x_2,\cdots$（可数无穷多）；
   2. 量词$\forall, \exists$；
   3. 联结词$\lnot,\land,\lor,\to$；
   4. 等词$\equiv$；
   5. 括号)，(

进一步要求$\mathcal L$是一个形式语言，就必须要求它的字母集及其每个子类都是能行可判定的，就是说，我们能行的程序来判定下面的问题：任给一个符号，它是不是$\mathcal L$的字母？是不是$\mathcal L$的逻辑符号？是不是$\mathcal L$的非逻辑符号？是逻辑符号的哪一类？是非逻辑符号的哪一类？

形式语言对其字母集（及其每个子类）的大小做了限定，要求它（它们）是可数的。

词项、公式等语言对象的形态最终由字母决定。又因为所有一阶语言有共同的逻辑符号，它们的字母表的差别完全由非逻辑符号决定，不妨把一个一阶语言就简单地看成它的非逻辑符号集。若它的非逻辑符号集是有穷的，我们就说这个语言是有穷的；反之就称这个语言是无穷的。

在谈论一个一阶语言的时候，我们需要一些元语言的变项来代表这个（对象）语言字母表中的任意某类符号。我们约定，在元语言中用

- x,y,x等代表一阶语言的个体变项；
- c,d,e等代表一阶语言的个体常项；
- P,Q,R等代表一阶语言的谓词；
- f,g,h等代表一阶语言的函数符号。"

## 2.归纳定义
一般而言，对一个集合A的`归纳定义`包含三个步骤：

1. 我们规定某些（不限于一个）特定的元素属于A，这一步叫`基始条件`。
2. 称`归纳条件`，它包含有穷的一组条件，其中每个条件涉及一个n($n \ge 1$)元函数f，并规定，对任何$a_1,\cdots,a_n \in A$，函数值$f(a_1,\cdots,a_n) \in A$。
3. 陈述的是`封闭条件`，它规定A只包含有穷步使用基始条件和归纳条件而得到的元素。

一个集合，如果对它有一个归纳定义，那么我们就可以设计一个有力的证明方法，来证明这个集合的全部元素都有某性质P，这个方法叫做`归纳证明`：对归纳定义的集合A，要证明任意$x \in A$都有P(x)，我们只要做两步工作：

1. 证明A的基始元素（基始条件确定的元素）都有性质P。这一步称为`归纳基始`。
2. 证明每个归纳条件涉及的函数都“保持”性质P。就是说，对任意这样的一个n元函数f，证明：如果$a_1,\cdots,a_n \in A$，且$P(a_1),\cdots,P(a_n)$，则$P(f(a_1,\cdots,a_n))$。这一步称为`归纳推步`，其中的条件——$a_1,\cdots,a_n \in A$且$P(a_1),\cdots,P(a_n)$——称为`归纳假设`。"

## 3.项
**3.1 定义**：对于一阶语言$\mathcal L$，一个$\mathcal L$的`符号串` （简称$\mathcal L$-串）是$\mathcal L$的字母表中的符号组成的一个有序n元组($n \ge 1$)，n称为这个$\mathcal L$-串的`长度`。

我们约定，在元语言中的$\lambda,\mu,\epsilon$等代表任意$\mathcal L$-串。如果$\mathcal L$的字母表为A，则$\mathcal L$-串的集合=$\cup\{A^n | n \ge 1\}$。

我们先前已经假定$\mathcal L$是可数语言，所以$\mathcal L$-串的集合是可数无穷大的。

对任意有穷个符号串$\lambda_1,\lambda_2,\cdots,\lambda_n$，我们用$\lambda_1\lambda_2\cdots\lambda_n$表示这n个字符串前后邻接起来形成的新符号串。如果$\lambda_1=f,\lambda_2=gf$，则$\lambda_1\lambda_2=fgf$。这使得我们可以对任意$n \ge 1$，在$\mathcal L$-串的集合上定义如下的n元`邻接函数`函数$C_n:C_n(\lambda_1,\lambda_2,\cdots,\lambda_n)=\lambda_1\lambda_2\cdots\lambda_n$

**3.3 定义**：设$\mathcal L$为一阶语言。$\mathcal L$-项定义为：

1. 基始条件：
   1. $\mathcal L$的字母表中的每个个体常项c是$\mathcal L$-项。
   2. 每个个体变项x是$\mathcal L$-项。
2. 归纳条件：对任意$n \ge 1$，若f是$\mathcal L$的n元函数符号，且$\mathcal L$-串$t_1,\cdots,t_n$是n个$\mathcal L$-项，则$\mathcal L$-串$ft_1\cdots t_n$也是$\mathcal L$-项。
3. 封闭条件：没有其他$\mathcal L$-串是$\mathcal L$-项。

对一个形式语言$\mathcal L$来说，一个符号是不是$\mathcal L$-项，或者是否属于$\mathcal L$-项的集合，是能行可判定的。这就是说，存在一个有穷长的机械过程过或程序，其中每一步到下一步都由确定的规则决定，而对每个符号串，在其上执行这个程序后，都在有穷步后得到一个是或否的答案，回答这个符号串是不是$\mathcal L$-项。一般而言，这样一种程序叫`算法`。对集合A，如果有一个算法来判定任意a是否属于A，则称A为`可判定的`。

**3.6 定理**：设$\mathcal L$为形式语言。$\mathcal L$-项的集合是可判定的。

如$\mathcal L$-项$f_2^2f_0^1c_1f_0^1f_1^2c_1x_0$的构造过程可以分析下面的分解树。

$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ c_1\ x_0$

---

$c_1\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ f_1^2c_1x_0\ (r_1)$

---

$f_0^1c_1\ (r_3)\ \ \ \ \ \ f_0^1f_1^2c_1x_0\ (r_2)$

---

$\ \ \ \ \ \ \ \ f_2^2f_0^1c_1f_0^1f_1^2c_1x_0$

每一层所有的符号串都是项。最上面没有横线的（叶上的项），是基始条件确定的项。即个体常项或个体变项；上面有横线的项，则表明它是横线之上的项根据归纳条件与适当的函数符号连接所形成的。下面没有横线的（根上的项），是最终形成的项。

如果项s（作为符号串）是项t的一部分（包括t本身），则称s是t的`子项`。项的分解树从根到叶，正是把根上的项拆开为其子项的过程。对每一枝来说，位置在上的每一项都是位置在下的所有项的子项；而树上的所有项，恰是根上的项的所有子项。所以，子项也可以这样定义：

s是t的子项，当且仅当s出现在t的分解树上。

**3.8 项的归纳证明**：设$\mathcal L$为一阶语言，P为关于$\mathcal L$-项的性质。要证明每个$\mathcal L$-项都具有性质P，只要证：

1. $\mathcal L$字母表中的每个个体常项具有性质P；
2. 每个个体变项具有性质P；
3. 对$\mathcal L$的n元函数符号f和$\mathcal L$-项$t_1\cdots t_n$，证明：若$t_1\cdots t_n$具有性质P，则$t_1\cdots t_n$-项$ft_1\cdots t_n$也有性质P。

**3.9 引理**：设$\mathcal L$为一阶语言。每个给定的$\mathcal L$-项的分解树都不同于其他项的分解树。

这个引理表明，不同的项有不同的分解树，每个项分解树只对应于一个项，因而从项分解树集到项集有一个函数关系，而且是满射。我们自然会问：这个函数是不是单射？或者，一个给定的项是不是只有唯一的分解树？既然一个项在语形上是一个符号串，那么，这个问题就相当于：以同一个项符号串为根，有没有可能存在不同的分解方法，从而产生两个不同的项分解树？

**3.10 引理**：如果符号串$\lambda$组成项，则$\lambda$只有唯一的项分解树。

**3.11 定理（项的读法唯一性）**：设$\lambda$为一个$\mathcal L$-串。如果$\lambda$组成$\mathcal L$-项t，又组成$\mathcal L$-项s，则t与s为同一个项。

这个事实从一个侧面反映了一阶语言的严格和精确：一个符号串如果组成项的话，则它只组成一个固定的项；不存在不同的读法，把其中符号排列重新“点断”，使得这个串同时也能组成另一个不同的项。日常语言中的词项，显然没有这种语形上的读法唯一性。"

## 4.公式
**4.1 定义**：设$\mathcal L$是任意一阶语言。$\mathcal L$的公式（或$\mathcal L$-公式）定义为：

1. 基始条件
   1. 对$\mathcal L$的任意n($n \ge 1$)元谓词P和任意n个$\mathcal L$-项$t_1t_2,...t_n,Pt_1t_2,...t_n$是$\mathcal L$-公式；
   2. 对任意的$\mathcal L$-项t和s，$t \equiv s$是公式。
2. 归纳条件
   1. 如果$\varphi$是$\mathcal L$-公式，则$\lnot \varphi$也是$\mathcal L$-公式；
   2. 如果$\varphi,\psi$是$\mathcal L$-公式，则$(\varphi \land \psi)$也是$\mathcal L$-公式；
   3. 如果$\varphi,\psi$是$\mathcal L$-公式，则$(\varphi \lor \psi)$也是$\mathcal L$-公式；
   4. 如果$\varphi,\psi$是$\mathcal L$-公式，则$(\varphi \to \psi)$也是$\mathcal L$-公式；
   5. 如果$\varphi$是$\mathcal L$-公式，x是个体变项，则$\forall x \varphi$也是$\mathcal L$-公式；
   6. 如果$\varphi$是$\mathcal L$-公式，x是个体变项，则$\exists x \varphi$也是$\mathcal L$-公式。

基始条件确定的公式，称为`原子公式`。2）中的公式1~4分别称为`否定式`、`合取式`、`析取式`和`蕴含式`，它们合称`布尔式`。2）中的5，6分别称为`全称式`和`存在式`。

显然，与$\mathcal L$-项的情形一样，每个$\mathcal L$-公式都是有穷长的。

**4.5 定理**：设$\mathcal L$为形式语言。$\mathcal L$-公式集是可判定的。

一个公式的`子公式`就是出现在它的分解树上的所有公式。

**4.10 定理（公式的读法唯一性）**：一个$\mathcal L$-串$\lambda$或者不是任何$\mathcal L$-公式，或者是唯一的一个$\mathcal L$-公式。

这个定理推广了项的读法唯一性定理，进一步表明了一阶语言的严格和精确：一个给定的公式，只有一种读法，不存在其他的点断方法，把它同时读为另一个公式。"

## 5.递归定义
给定$\mathcal L$-公式集，其上的秩可以如下分步定义：

1. 对于$\mathcal L$的原子公式$\varphi,r(\varphi)=0$；
2. 对于$\mathcal L$的非原子公式$\varphi$，
   1. 如果$\varphi$为$\lnot \psi$，则$r(\varphi)=r(\psi)+1$；
   2. 如果$\varphi$为$\psi_1 \Box \psi_2,\Box \in \{\land,\lor,\lnot,\to\}$，则$r(\varphi)=r(\psi_1)+r(\psi_2)+1$；
   3. 如果$\varphi$为$\diamond x \psi,\diamond \in \{\forall,\exists\}$，则$r(\varphi)=r(\psi)+1$；

这种定义函数的方法叫`递归定义`。

**5.1 定义**：设$\mathcal L$为一阶语言。一个$\mathcal L$-项的所有子项形成一个$\mathcal L$-项的集合，记为S(t)。其中S为从$\mathcal L$-项集到其幂集的函数，按如下方式递归定义：

1. 若t为个体常项或变项，则S(t)={t}；
2. 若t为$ft_1\cdots t_n$，其中$t_1,t_2,\cdots,t_n$为$\mathcal L$-项，则$S(t)=S(t_1) \cup \cdots S(t_n) \cup \{ft_1 \cdots t_n\}$。

**5.2 定义**：设$\mathcal L$为一阶语言。一个$\mathcal L$-公式$\varphi$的所有子公式形成一个$\mathcal L$-公式的集合，记为S($\varphi$)。其中S为从$\mathcal L$-公式集到其幂集的函数，按如下方式递归定义：

1. 若$\varphi$为原子公式，则$S(\varphi)=\{\varphi\}$；
2. 设$\varphi$为非原子公式，
   1. 如果$\varphi$为$\lnot \psi$，则$S(\varphi)=S(\psi) \cup \{\lnot \psi\}$；
   2. 如果$\varphi$为$\psi_1 \Box \psi_2,\Box \in \{\land,\lor,\lnot,\to\}$，则$S(\varphi)=S(\psi_1) \cup S(\psi_2) \cup \{\psi_1 \Box \psi_2\}$；
   3. 如果$\varphi$为$\diamond x \psi,\diamond \in \{\forall,\exists\}$，则$S(\varphi)=S(\psi) \cup \{\diamond x \psi\}$。"

## 6.自由和约束 代入
**6.1 定义**：对一个量化式$\forall x \varphi$（或$\exists x \varphi$），称其子公式$\varphi$是量词$\forall x$（或$\exists x$）的`辖域`。一般而言，如果$\forall x \varphi$（或$\exists x \varphi$）作为公式出现在公式$\psi$中，则称$\varphi$是这处量词在$\psi$中的辖域。

**6.2 定义**：在公式$\varphi$中，一个变项x如果出现在某个形如$\forall x$(或$\exists x$)的量词的某处辖域中，则称x在$\varphi$中的这处出现（以及它在这个量词中的出现）是`约束的`。变项的非约束的出现，称为`自由出现`。

如果x出现在$\varphi$中，只要x有一处自由出现，就称x是$\varphi$中的`自由变项`；否则称x为$\varphi$的`约束变项`。

我们称含有自由变项的公式为`开公式`，称不含有自由变项的公式为`闭公式`或`语句`。

**6.5 定义**：设$\mathcal L$是一个一阶语言，$s(x_1,x_2,\cdots,x_n)$是一个$\mathcal L$-项对任意$\mathcal L$-项。$t_1,t_2,\cdots,t_n$，我们如下递归定义$t_1,t_2,\cdots,t_n$在s中对$x_1,x_2,\cdots,x_n$的`代入`，代入结果记为$s(t_1/x_1,t_2/x_2,\cdots,t_n/x_n)$:

1. 若s为个体常项，则$s(t_1/x_1,t_2/x_2,\cdots,t_n/x_n)=s$；
2. 若s为个体变项y，则
$$s(t_1/x_1,t_2/x_2,\cdots,t_n/x_n)=\left\{\begin{matrix}
 t_1,& if\ x_i=y,for\ some\ i(1 \le i \le n) > 0 \\ 
 y, & elsewise.
\end{matrix}\right.$$
3. 若s为$fs_1\cdots s_n$，则$s(t_1/x_1,t_2/x_2,\cdots,t_n/x_n)=fs_1(t_1/x_1,t_2/x_2,\cdots,t_n/x_n) \cdots s_n(t_1/x_1,t_2/x_2,\cdots,t_n/x_n)$。

容易归纳证明$s(t_1/x_1,t_2/x_2,\cdots,t_n/x_n)$仍然是$\mathcal L$-项。

**6.6 定义**：设$\mathcal L$是一个一阶语言，$\varphi(x_1,x_2,\cdots,x_n)$是一个$\mathcal L$-公式。对任意$\mathcal L$-项$t_1,t_2,\cdots,t_n$，我们如下归纳定义$t_1,t_2,\cdots,t_n$在$\varphi$中对$x_1,x_2,\cdots,x_n$的`代入`，代入结果记为$\varphi(t_1/x_1,t_2/x_2,\cdots,t_n/x_n)$:

1. 若$\varphi$为原子公式$Ps_1\cdots s_n$，则$\varphi(t_1/x_1,t_2/x_2,\cdots,t_n/x_n)=Ps_1(t_1/x_1,t_2/x_2,\cdots,t_n/x_n)\cdots s_n(t_1/x_1,t_2/x_2,\cdots,t_n/x_n)$；
2. 若$\varphi$为原子公式$s_1 \equiv s_2$，则$\varphi(t_1/x_1,t_2/x_2,\cdots,t_n/x_n)=s_1(t_1/x_1,t_2/x_2,\cdots,t_n/x_n) \equiv s_2(t_1/x_1,t_2/x_2,\cdots,t_n/x_n)$；
3. 若$\varphi$为$\lnot \psi$，则$\varphi(t_1/x_1,t_2/x_2,\cdots,t_n/x_n)=\lnot \psi(t_1/x_1,t_2/x_2,\cdots,t_n/x_n)$；
4. 若$\varphi$为$\psi_1 \Box \psi_2,\Box \in \{\land,\lor,\lnot,\to\}$，则$\varphi(t_1/x_1,t_2/x_2,\cdots,t_n/x_n)=\psi_1(t_1/x_1,t_2/x_2,\cdots,t_n/x_n) \Box \psi_2(t_1/x_1,t_2/x_2,\cdots,t_n/x_n)$；
5. 若$\varphi$为$\diamond y \psi,\diamond \in \{\forall,\exists\}$，则$\psi(t_1/x_1,t_2/x_2,\cdots,t_n/x_n)=\left\{\begin{matrix}
 \diamond y \psi(\cdots,t_{i-1}/x_{i-1},t_{i+1}/x_{i+1},\cdots),& if\ x_i=y,for\ some\ i(1 \le i \le n) > 0 \ 
 \diamond y \psi(t_1/x_1,t_2/x_2,\cdots,t_n/x_n), & elsewise.
\end{matrix}\right.$

容易归纳证明，$\varphi(t_1/x_1,t_2/x_2,\cdots,t_n/x_n)$仍然是$\mathcal L$-公式。"



















































































































































































































