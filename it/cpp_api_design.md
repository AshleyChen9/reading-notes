# C++ API设计
![cover](https://img3.doubanio.com/lpic/s26853334.jpg)

[豆瓣链接](https://book.douban.com/subject/24869855/)

	作者: [美] Martin Reddy
	出版社: 人民邮电出版社
	原作名: API Design for C++
	译者: 刘晓娜 / 臧秀涛 / 林健
	出版年: 2013-8
	页数: 380
	定价: 89.00
	装帧: 平装
	ISBN: 9787115322999

---

## C++ API 兼容性 
### 1 向后兼容
向后兼容可定义为API提供与上一版本相同的功能。这暗示了新版本API是旧版本API的超集。可以添加新的功能，但是不能对旧API定义的已有功能做不兼容的修改。向后兼容性有不同类型：

* 功能性兼容
* 源代码兼容
* 二进制兼容

### 2 功能性兼容
如果一个API的行为与上一版本精确一致，那么它就是功能性兼容。API在这方面几乎无法达到100%的向后兼容。即使仅修正了实现代码中一些错误的行为，而某些客户端可能确实依赖这些行为。考虑一个API，它的新版本仅关注性能，API的行为没有改变，此时API可认为是100%功能兼容的。

### 3 源代码兼容
用户可以使用新版本的API重新编译程序，而不用对代码做任何修改。这个概念不涉及编译出的程序的行为，只要能够成功编译并链接即可。源代码兼容也称API兼容。一个源代码兼容例子：

```cpp
// version 1.0
void SetImage(Image* img);

// version 1.1
void SetImage(Image* img, bool keepAspect=true);
```

不是源代码兼容例子：

```cpp
// version 1.0
void SetImage(Image* img);

// version 1.1
void SetImage(Image* img, bool keepAspect);
```

### 4 二进制兼容
二进制兼容意味着客户需要做的只是使用新版本的静态库重新链接他们的程序，或把新的共享库放入最终用户应用程序的安装目录。用户不需要重新编译他们的程序。下面的例子是源代码兼容，不是二进制兼容：

```cpp
// version 1.0
void SetImage(Image* img);//Z8SetImageP5Image

// version 1.1
void SetImage(Image* img, bool keepAspect=true);//Z8SetImageP5Imageb
```

二进制不兼容的API修改：

* 移除类、方法或函数
* 增加、移除类中的成员变量，或者重新排序成员变量
* 增加或移除一个类的基类
* 修改任何成员变量的类型
* 以任何方式修改已有方法的签名
* 增加、移除模版参数，或重新排序模版参数
* 把非内联方法改为内联方法
* 把非虚函数改为虚函数，反之亦然
* 改变虚方法的顺序
* 给没有虚方法的类增加虚方法
* 增加新的虚方法(对于某些编译器，如果在已有的虚方法后面增加新的虚方法，有可能保持二进制兼容)
* 覆盖已有的虚方法(某些情况下可能可行)

二进制兼容的API修改：

* 增加新的类、非虚方法或者函数
* 给类增加新的静态变量
* 移除私有静态变量(前提是它们从来没有再内联方法中引用)
* 移除非虚私有方法(前提是它们从来没有再内联方法中引用)
* 修改内联方法的实现(要使用新的实现就必须重新编译)
* 把内联方法修改为非内联方法(如果实现也被修改，那必须重新编译)
* 修改方法的默认参数(要使用新的实现就必须重新编译)
* 给类增加或移除友元声明
* 给类增加新的枚举
* 给已存在的枚举增加新的枚举量
* 使用位域中未声明的余留位

### 5 向前兼容
向前兼容意味着用户可以降级到之前发布的版本，代码无需修改，仍然可以正常工作。为API增加新功能会破坏向前兼容性，因为利用新特想编写的客户代码不能编译不包括这些特性的老版本API。
